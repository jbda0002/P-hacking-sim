h1=qbern(u[,7],0.5)
data = as.data.frame(cbind(r[,1:6],h1))
names(data) = c('y1', 'x1', 'x2','x3','x4','x5','h1')
return(data)
}
dataGen6 <- function(N,cor){
M = matrix(c(1, cor, cor, cor,cor,cor,cor,0,
cor, 1, 0, 0, 0, 0,0,0,
cor, 0, 1, 0, 0, 0,0,0,
cor, 0, 0, 1, 0, 0,0,0,
cor, 0, 0, 0, 1, 0,0,0,
cor, 0, 0, 0, 0, 1,0,0,
cor, 0, 0, 0, 0, 0,1,0,
0,0,0,0,0,0,0,1
), nrow=8, ncol=8)
L = chol(M)
nvars = dim(L)[1]
r = t(L) %*% matrix(rnorm(nvars*N), nrow=nvars, ncol=N)
r = t(r)
u <- pnorm(r)
h1=qbern(u[,8],0.5)
data = as.data.frame(cbind(r[,1:7],h1))
names(data) = c('y1', 'x1', 'x2','x3','x4','x5','x6','h1')
return(data)
}
dataGen7 <- function(N,cor){
M = matrix(c(1, cor, cor, cor,cor,cor,cor,cor,0,
cor, 1, 0, 0, 0, 0,0,0,0,
cor, 0, 1, 0, 0, 0,0,0,0,
cor, 0, 0, 1, 0, 0,0,0,0,
cor, 0, 0, 0, 1, 0,0,0,0,
cor, 0, 0, 0, 0, 1,0,0,0,
cor, 0, 0, 0, 0, 0,1,0,0,
cor, 0, 0, 0, 0, 0, 0,1,0,
0,0,0,0,0,0,0,0,1
), nrow=9, ncol=9)
L = chol(M)
nvars = dim(L)[1]
r = t(L) %*% matrix(rnorm(nvars*N), nrow=nvars, ncol=N)
r = t(r)
u <- pnorm(r)
h1=qbern(u[,9],0.5)
data = as.data.frame(cbind(r[,1:8],h1))
names(data) = c('y1', 'x1', 'x2','x3','x4','x5','x6','x7','h1')
return(data)
}
data=dataGen3(300,0.2)
phackingFunction(data,"y1","h1")
## Loading the P-Hacking function
source(here::here("phackingFunction_v2-0.R"))
## Making the list for the Normal Data
source("Data Generation Normal.R")
DataGenListNorm <- list(dataGen2,dataGen3,dataGen4)
## Making the list for the Bin Data
source("Data Generation Bin.R")
DataGenListBin <- list(dataGen2,dataGen3,dataGen4)
## Making the list for the Bin Data
source("Data Generation BinNormal.R")
DataGenListBinNorm <- list(dataGen2,dataGen3,dataGen4)
## Making the list for the Bin Data
source("Data Generation NormalBin.R")
DataGenListNormBin <- list(dataGen2,dataGen3,dataGen4)
#### Run the simulation ####
## General for all
## The different condetions
P2<-c("TRUE","FALSE")
P3<-c("TRUE","FALSE")
condSD<-c("FALSE")
condcor<-c("TRUE","FALSE")
## Making a list to store the results
finalresult<-list(finalresultNorm=c(),finalresultBin=c(),finalresultNormBin=c(),finalresultBinNorm=c())
## Collecting the different datatypes in one list
DataGen<-list(m1=DataGenListNorm,m2=DataGenListBin,m3=DataGenListNormBin,m4=DataGenListBinNorm)
## Choosing how many workers there should be used
cl <- makeSOCKcluster(4)
#clusterExport(cl,c("DataGen","sample","condIn","condSD"))
## Using the SNOW packed as this gives the ability to make a process bar
registerDoSNOW(cl)
## Making the process bar. The process bar will stand still towards the end, as it cannot take into account the time mapply will take
pb <- txtProgressBar(max=length(DataGenListBin)*length(DataGen)*length(condSD)*length(P2)*length(P3)*length(sample), style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
results<-
foreach(k=1:length(condSD),.combine=rbind) %:%
foreach(h=1:length(P2),.combine=rbind, .inorder=FALSE) %:%
foreach(l=1:length(P3),.combine=rbind, .inorder=FALSE) %:%
foreach(g=1:length(sample),.combine=rbind, .inorder=FALSE) %:%
foreach(i=1:length(DataGen),.combine=rbind, .inorder=FALSE) %:%
foreach(j=1:length(DataGen[[i]]),.combine=rbind,.packages=c("plyr","statip","data.table"), .inorder=FALSE) %dopar% {
f = function() {
x<-(replicate(rep, phackingFunction(DataGen[[i]][[j]](sample[[g]],per),"y1","h1",Power_2 =P2[[h]],SD=condSD[[k]],Power_3 = P3[[l]])))
Stats<-t(c(mean(x),(sd(x)/sqrt(length(x)))))
Stats
}
data.frame(f(),Power2=h,Power3=l,OutlierExclusion=k,IndependentVariables=j,Type=i,SampleSize=sample[[g]])
}
results<-as.data.frame(results)
names(results)[1]<-"Pr"
names(results)[2]<-"Sde"
## Close process bar
close(pb)
## Stop the workers
stopCluster(cl);print("Cluster stopped")
registerDoSEQ()
View(results)
## Selecting the sample sizes that should be used
sample = c(50,100,150)
## Setting the number of repretetion
rep=40
## Setting the correlation between dependent and independent
per=0.2
## Loading the P-Hacking function
source(here::here("phackingFunction_v2-0.R"))
## Making the list for the Normal Data
source("Data Generation Normal.R")
DataGenListNorm <- list(dataGen1,dataGen2,dataGen3,dataGen4)
## Making the list for the Bin Data
source("Data Generation Bin.R")
DataGenListBin <- list(dataGen1,dataGen2,dataGen3,dataGen4)
## Making the list for the Bin Data
source("Data Generation BinNormal.R")
DataGenListBinNorm <- list(dataGen1,dataGen2,dataGen3,dataGen4)
## Making the list for the Bin Data
source("Data Generation NormalBin.R")
DataGenListNormBin <- list(dataGen1,dataGen2,dataGen3,dataGen4)
#### Run the simulation ####
## General for all
## The different condetions
P2<-c("TRUE","FALSE")
P3<-c("TRUE","FALSE")
condSD<-c("TRUE","FALSE")
condcor<-c("TRUE","FALSE")
## Making a list to store the results
finalresult<-list(finalresultNorm=c(),finalresultBin=c(),finalresultNormBin=c(),finalresultBinNorm=c())
## Collecting the different datatypes in one list
DataGen<-list(m1=DataGenListNorm,m2=DataGenListBin,m3=DataGenListNormBin,m4=DataGenListBinNorm)
## Choosing how many workers there should be used
cl <- makeSOCKcluster(4)
#clusterExport(cl,c("DataGen","sample","condIn","condSD"))
## Using the SNOW packed as this gives the ability to make a process bar
registerDoSNOW(cl)
## Making the process bar. The process bar will stand still towards the end, as it cannot take into account the time mapply will take
pb <- txtProgressBar(max=length(DataGenListBin)*length(DataGen)*length(condSD)*length(P2)*length(P3)*length(sample), style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
results<-
foreach(k=1:length(condSD),.combine=rbind) %:%
foreach(h=1:length(P2),.combine=rbind, .inorder=FALSE) %:%
foreach(l=1:length(P3),.combine=rbind, .inorder=FALSE) %:%
foreach(g=1:length(sample),.combine=rbind, .inorder=FALSE) %:%
foreach(i=1:length(DataGen),.combine=rbind, .inorder=FALSE) %:%
foreach(j=1:length(DataGen[[i]]),.combine=rbind,.packages=c("plyr","statip","data.table"), .inorder=FALSE) %dopar% {
f = function() {
x<-(replicate(rep, phackingFunction(DataGen[[i]][[j]](sample[[g]],per),"y1","h1",Power_2 =P2[[h]],SD=condSD[[k]],Power_3 = P3[[l]])))
Stats<-t(c(mean(x),(sd(x)/sqrt(length(x)))))
Stats
}
data.frame(f(),Power2=h,Power3=l,OutlierExclusion=k,IndependentVariables=j,Type=i,SampleSize=sample[[g]])
}
getDoParWorkers()
stopCluster(cl);print("Cluster stopped")
registerDoSEQ()
getDoParWorkers()
numCores <- detectCores()
numCores
#### Run the simulation ####
## General for all
## The different condetions
P2<-c("TRUE","FALSE")
P3<-c("TRUE","FALSE")
condSD<-c("TRUE","FALSE")
condcor<-c("TRUE","FALSE")
## Making a list to store the results
finalresult<-list(finalresultNorm=c(),finalresultBin=c(),finalresultNormBin=c(),finalresultBinNorm=c())
## Collecting the different datatypes in one list
DataGen<-list(m1=DataGenListNorm,m2=DataGenListBin,m3=DataGenListNormBin,m4=DataGenListBinNorm)
## Choosing how many workers there should be used
cl <- makeSOCKcluster(7)
#clusterExport(cl,c("DataGen","sample","condIn","condSD"))
## Using the SNOW packed as this gives the ability to make a process bar
registerDoSNOW(cl)
## Making the process bar. The process bar will stand still towards the end, as it cannot take into account the time mapply will take
pb <- txtProgressBar(max=length(DataGenListBin)*length(DataGen)*length(condSD)*length(P2)*length(P3)*length(sample), style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
results<-
foreach(k=1:length(condSD),.combine=rbind) %:%
foreach(h=1:length(P2),.combine=rbind, .inorder=FALSE) %:%
foreach(l=1:length(P3),.combine=rbind, .inorder=FALSE) %:%
foreach(g=1:length(sample),.combine=rbind, .inorder=FALSE) %:%
foreach(i=1:length(DataGen),.combine=rbind, .inorder=FALSE) %:%
foreach(j=1:length(DataGen[[i]]),.combine=rbind,.packages=c("plyr","statip","data.table"),.options.snow = opts, .inorder=FALSE) %dopar% {
f = function() {
x<-(replicate(rep, phackingFunction(DataGen[[i]][[j]](sample[[g]],per),"y1","h1",Power_2 =P2[[h]],SD=condSD[[k]],Power_3 = P3[[l]])))
Stats<-t(c(mean(x),(sd(x)/sqrt(length(x)))))
Stats
}
data.frame(f(),Power2=h,Power3=l,OutlierExclusion=k,IndependentVariables=j,Type=i,SampleSize=sample[[g]])
}
results<-as.data.frame(results)
names(results)[1]<-"Pr"
names(results)[2]<-"Sde"
## Close process bar
close(pb)
## Stop the workers
stopCluster(cl);print("Cluster stopped")
registerDoSEQ()
length(DataGenListBin)*length(DataGen)*length(condSD)*length(P2)*length(P3)*length(sample)
## Choosing how many workers there should be used
cl <- makeSOCKcluster(7)
#clusterExport(cl,c("DataGen","sample","condIn","condSD"))
## Using the SNOW packed as this gives the ability to make a process bar
registerDoSNOW(cl)
## Making the process bar. The process bar will stand still towards the end, as it cannot take into account the time mapply will take
pb <- txtProgressBar(max=length(DataGenListBin)*length(DataGen)*length(condSD)*length(P2)*length(P3)*length(sample), style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
results<-
foreach(k=1:length(condSD),.combine=rbind) %:%
foreach(h=1:length(P2),.combine=rbind, .inorder=FALSE) %:%
foreach(l=1:length(P3),.combine=rbind, .inorder=FALSE) %:%
foreach(g=1:length(sample),.combine=rbind, .inorder=FALSE) %:%
foreach(i=1:length(DataGen),.combine=rbind, .inorder=FALSE) %:%
foreach(j=1:length(DataGen[[i]]),.combine=rbind,.packages=c("plyr","statip","data.table"),.options.snow = opts, .inorder=FALSE) %dopar% {
f = function() {
x<-(replicate(rep, phackingFunction(DataGen[[i]][[j]](sample[[g]],per),"y1","h1",Power_2 =P2[[h]],SD=condSD[[k]],Power_3 = P3[[l]])))
Stats<-t(c(mean(x),(sd(x)/sqrt(length(x)))))
Stats
}
data.frame(f(),Power2=h,Power3=l,OutlierExclusion=k,IndependentVariables=j,Type=i,SampleSize=sample[[g]])
}
results<-
foreach(k=1:length(condSD),.combine=rbind) %:%
foreach(h=1:length(P2),.combine=rbind, .inorder=FALSE) %:%
foreach(l=1:length(P3),.combine=rbind, .inorder=FALSE) %:%
foreach(g=1:length(sample),.combine=rbind, .inorder=FALSE) %:%
foreach(i=1:length(DataGen),.combine=rbind, .inorder=T) %:%
foreach(j=1:length(DataGen[[i]]),.combine=rbind,.packages=c("plyr","statip","data.table"),.options.snow = opts, .inorder=FALSE) %dopar% {
f = function() {
x<-(replicate(rep, phackingFunction(DataGen[[i]][[j]](sample[[g]],per),"y1","h1",Power_2 =P2[[h]],SD=condSD[[k]],Power_3 = P3[[l]])))
Stats<-t(c(mean(x),(sd(x)/sqrt(length(x)))))
Stats
}
data.frame(f(),Power2=h,Power3=l,OutlierExclusion=k,IndependentVariables=j,Type=i,SampleSize=sample[[g]])
}
library(here)
dr_here()
set_here()
# ## Jacob
source(here::here("remove_outliers_sd.R"))
source(here::here( "remove_outliers_range.R"))
library(here)
getwd()
# ## Jacob
source(here::here("remove_outliers_sd.R"))
here()
set_here()
library(here)
# ## Jacob
source(here::here("remove_outliers_sd.R"))
dataGen1 <- function(N,cor){
M = matrix(c(1, 0, cor,
0, 1, 0,
cor, 0, 1
), nrow=3, ncol=3)
L = chol(M)
nvars = dim(L)[1]
r = t(L) %*% matrix(rnorm(nvars*N), nrow=nvars, ncol=N)
r = t(r)
data = as.data.frame(r)
names(data) = c('y1', 'h1', 'x1')
return(data)
}
data=dataGen1(200,0.2)
#setwd("/Users/au549385/Dropbox/P-Hacking paper/R/Analysis/Code")
source(here::here("Dropbox", "P-Hacking paper", "R", "Analysis", "Code", "remove_outliers_sd.R"))
#setwd("/Users/au549385/Dropbox/P-Hacking paper/R/Analysis/Code")
source(here::here("P-Hacking paper", "R", "Analysis", "Code", "remove_outliers_sd.R"))
library(dplyr)
View(data)
dataGen2 <- function(N,cor){
M = matrix(c(1, 0, cor,cor,
0, 1, 0,0,
cor, 0, 1,0,
cor,0,0,1
), nrow=4, ncol=4)
L = chol(M)
nvars = dim(L)[1]
r = t(L) %*% matrix(rnorm(nvars*N), nrow=nvars, ncol=N)
r = t(r)
data = as.data.frame(r)
names(data) = c('y1', 'h1', 'x1','x2')
return(data)
}
data=dataGen2(200,0.2)
View(data)
library(dplyr)
#Collecting and counting all the different variables, except the DV and H_1
Cols <- names(data)
y="y1"
H_1="h1"
Cols <- Cols[! Cols %in% c(y,H_1)]
n <- length(Cols)
#Making objects for saving model versions. RModelI has the dimensions that is needed to collect all the p-values
ModelName = NULL
## If h1 is a factor, then the placeholer for the interaction must be changed
if(sapply(data[grep(H_1, colnames(data))], is.factor)==TRUE){
level=sapply(data[grep(H_1, colnames(data))], nlevels)-1
RModelI = as.data.frame(matrix(0, ncol = n*level, nrow = 0))
RModelF=as.data.frame(matrix(0, ncol = level, nrow = 0))
}
if(sapply(data[grep(H_1, colnames(data))], is.factor)==F){
RModelI = as.data.frame(matrix(0, ncol = n, nrow = 0))
RModelF = NULL
}
#Making different combinations of the variables
Combin <- unlist(
lapply(1:n, function(i)combn(1:n,i,simplify=FALSE)), recursive=FALSE)
mvDV <- ifelse(length(y) >= 2, TRUE, FALSE)
if (mvDV == TRUE) {
#Make average
data <- data[c(y, H_1, Cols)]
data$yavg <-
1 / length(y) * rowSums(data[1:length(y)]) #double check that it outputs correct result
if (SD == TRUE) {
for (j in 1:length(dataoutlier)) {
dataoutlier[[j]] <- dataoutlier[[j]][c(y, H_1, Cols)]
dataoutlier[[j]]$yavg <-
1 / length(y) * rowSums(dataoutlier[[j]][1:length(y)])
}
}
# Add this to the list of dependent variables
y = c(y, "yavg")
start = NULL
for (i in 1:length(y)) {
start_i <- paste(c(y[i], "~", H_1, "+"), collapse = " ")
start <- rbind(start, start_i)
}
} else {
#Starting of regression if there is no several dependent variables
start <- paste(c(y, "~", H_1, "+"), collapse = " ")
}
start
## Make all the regressions without interaction terms.
Formulas=sapply(Combin,function(i)
paste(start,paste(Cols[i],collapse=" + ")))
Power1=Formulas
## This is Power(1) and Power(2)
#Starting of interaction term
CombinInter <- unlist(
lapply(1, function(i)combn(1:n,i,simplify=FALSE)), recursive=FALSE)
## Put together the random variable and all the dependent variables
CombH1<-paste(c(H_1,"*"),collapse =" ")
#All interactions terms
Interactions <- sapply(CombinInter,function(i)
paste(CombH1,paste(Cols[i],collapse=" ")))
## Make the models with the interaction terms
FormulasIN <- sapply(Combin,function(i)
paste(start,paste(Interactions[i],collapse=" + "))) #I removed plus
Combin
Cols
FormulasIN
Combinations=Combin
names=Cols
formula=FormulasIN
Test = sapply(Combinations, function(i)
paste(names[i], collapse = "|"))
## Make object to capture the functions where to add main effect
FoirmulasInC = NULL
for (j in 1:length(Test)) {
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
## For those where the term is not part of the interaction term, add them
for (k in loop) {
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
## Change the | to a +
Form = gsub("\\|", " + ", Form)
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
}
}
FoirmulasInC
loop
Test = sapply(Combinations, function(i)
paste(names[i], collapse = "|"))
Test
## Make object to capture the functions where to add main effect
FoirmulasInC = NULL
j=2
for (j in 1:length(Test)) {
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
## For those where the term is not part of the interaction term, add them
for (k in loop) {
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
## Change the | to a +
Form = gsub("\\|", " + ", Form)
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
}
}
loop
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
j=2
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
Form
## Change the | to a +
Form = gsub("\\|", " + ", Form)
Form
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
FoirmulasInC
Combin
Cols
FormulasIN
Test
## Make object to capture the functions where to add main effect
FoirmulasInC = NULL
for (j in 1:length(Test)) {
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
## For those where the term is not part of the interaction term, add them
for (k in loop) {
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
## Change the | to a +
Form = gsub("\\|", " + ", Form)
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
}
}
FoirmulasInC
## Make object to capture the functions where to add main effect
FoirmulasInC = NULL
j=3
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
j=1
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
Test
j=2
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
Form
## Change the | to a +
Form = gsub("\\|", " + ", Form)
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
FoirmulasInC
dataGen3 <- function(N,cor){
M = matrix(c(1, 0, cor, cor,cor,
0, 1, 0, 0,0,
cor, 0, 1, 0,0,
cor, 0, 0, 1,0,
cor, 0, 0, 0, 1), nrow=5, ncol=5)
L = chol(M)
nvars = dim(L)[1]
r = t(L) %*% matrix(rnorm(nvars*N), nrow=nvars, ncol=N)
r = t(r)
u <- pnorm(r)
y1=r[,1]
x1=qbern(u[,3],0.5)
x2=qbern(u[,4],0.5)
x3=qbern(u[,5],0.5)
h1=r[,2]
data = as.data.frame(cbind(y1,h1,x1,x2,x3))
return(data)
}
data=datagen3(100,0.3)
dataGen4 <- function(N,cor){
M = matrix(c(1, 0, cor, cor,cor,cor,
0, 1, 0, 0, 0, 0,
cor, 0, 1, 0, 0, 0,
cor, 0, 0, 1, 0, 0,
cor, 0, 0, 0, 1, 0,
cor, 0, 0, 0, 0, 1), nrow=6, ncol=6)
L = chol(M)
nvars = dim(L)[1]
r = t(L) %*% matrix(rnorm(nvars*N), nrow=nvars, ncol=N)
r = t(r)
u <- pnorm(r)
y1=r[,1]
x1=qbern(u[,3],0.5)
x2=qbern(u[,4],0.5)
x3=qbern(u[,5],0.5)
x4=qbern(u[,6],0.5)
h1=r[,2]
data = as.data.frame(cbind(y1,h1,x1,x2,x3,x4))
return(data)
}
data=dataGen4(100,0.3)
data=dataGen1(100,0.3)
data=dataGen2(100,0.3)
data=dataGen3(100,0.3)
library(dplyr)
library(here)
library(dplyr)
library(here)
