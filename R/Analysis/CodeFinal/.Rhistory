RModelF = NULL
}
#Making different combinations of the variables
Combin <- unlist(
lapply(1:n, function(i)combn(1:n,i,simplify=FALSE)), recursive=FALSE)
mvDV <- ifelse(length(y) >= 2, TRUE, FALSE)
if (mvDV == TRUE) {
#Make average
data <- data[c(y, H_1, Cols)]
data$yavg <-
1 / length(y) * rowSums(data[1:length(y)]) #double check that it outputs correct result
if (SD == TRUE) {
for (j in 1:length(dataoutlier)) {
dataoutlier[[j]] <- dataoutlier[[j]][c(y, H_1, Cols)]
dataoutlier[[j]]$yavg <-
1 / length(y) * rowSums(dataoutlier[[j]][1:length(y)])
}
}
# Add this to the list of dependent variables
y = c(y, "yavg")
start = NULL
for (i in 1:length(y)) {
start_i <- paste(c(y[i], "~", H_1, "+"), collapse = " ")
start <- rbind(start, start_i)
}
} else {
#Starting of regression if there is no several dependent variables
start <- paste(c(y, "~", H_1, "+"), collapse = " ")
}
start
## Make all the regressions without interaction terms.
Formulas=sapply(Combin,function(i)
paste(start,paste(Cols[i],collapse=" + ")))
Power1=Formulas
## This is Power(1) and Power(2)
#Starting of interaction term
CombinInter <- unlist(
lapply(1, function(i)combn(1:n,i,simplify=FALSE)), recursive=FALSE)
## Put together the random variable and all the dependent variables
CombH1<-paste(c(H_1,"*"),collapse =" ")
#All interactions terms
Interactions <- sapply(CombinInter,function(i)
paste(CombH1,paste(Cols[i],collapse=" ")))
## Make the models with the interaction terms
FormulasIN <- sapply(Combin,function(i)
paste(start,paste(Interactions[i],collapse=" + "))) #I removed plus
Combin
Cols
FormulasIN
Combinations=Combin
names=Cols
formula=FormulasIN
Test = sapply(Combinations, function(i)
paste(names[i], collapse = "|"))
## Make object to capture the functions where to add main effect
FoirmulasInC = NULL
for (j in 1:length(Test)) {
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
## For those where the term is not part of the interaction term, add them
for (k in loop) {
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
## Change the | to a +
Form = gsub("\\|", " + ", Form)
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
}
}
FoirmulasInC
loop
Test = sapply(Combinations, function(i)
paste(names[i], collapse = "|"))
Test
## Make object to capture the functions where to add main effect
FoirmulasInC = NULL
j=2
for (j in 1:length(Test)) {
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
## For those where the term is not part of the interaction term, add them
for (k in loop) {
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
## Change the | to a +
Form = gsub("\\|", " + ", Form)
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
}
}
loop
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
j=2
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
Form
## Change the | to a +
Form = gsub("\\|", " + ", Form)
Form
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
FoirmulasInC
Combin
Cols
FormulasIN
Test
## Make object to capture the functions where to add main effect
FoirmulasInC = NULL
for (j in 1:length(Test)) {
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
## For those where the term is not part of the interaction term, add them
for (k in loop) {
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
## Change the | to a +
Form = gsub("\\|", " + ", Form)
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
}
}
FoirmulasInC
## Make object to capture the functions where to add main effect
FoirmulasInC = NULL
j=3
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
j=1
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
Test
j=2
## Test if variable is part of the interaction term
loop = grep(Test[j], formula, invert = TRUE)
loop
## Paste on the main effects that are needed
Form = paste(formula[k], paste("+", Test[j]))
Form
## Change the | to a +
Form = gsub("\\|", " + ", Form)
## Put them into a list
FoirmulasInC = rbind(Form, FoirmulasInC)
FoirmulasInC
dataGen3 <- function(N,cor){
M = matrix(c(1, 0, cor, cor,cor,
0, 1, 0, 0,0,
cor, 0, 1, 0,0,
cor, 0, 0, 1,0,
cor, 0, 0, 0, 1), nrow=5, ncol=5)
L = chol(M)
nvars = dim(L)[1]
r = t(L) %*% matrix(rnorm(nvars*N), nrow=nvars, ncol=N)
r = t(r)
u <- pnorm(r)
y1=r[,1]
x1=qbern(u[,3],0.5)
x2=qbern(u[,4],0.5)
x3=qbern(u[,5],0.5)
h1=r[,2]
data = as.data.frame(cbind(y1,h1,x1,x2,x3))
return(data)
}
data=datagen3(100,0.3)
dataGen4 <- function(N,cor){
M = matrix(c(1, 0, cor, cor,cor,cor,
0, 1, 0, 0, 0, 0,
cor, 0, 1, 0, 0, 0,
cor, 0, 0, 1, 0, 0,
cor, 0, 0, 0, 1, 0,
cor, 0, 0, 0, 0, 1), nrow=6, ncol=6)
L = chol(M)
nvars = dim(L)[1]
r = t(L) %*% matrix(rnorm(nvars*N), nrow=nvars, ncol=N)
r = t(r)
u <- pnorm(r)
y1=r[,1]
x1=qbern(u[,3],0.5)
x2=qbern(u[,4],0.5)
x3=qbern(u[,5],0.5)
x4=qbern(u[,6],0.5)
h1=r[,2]
data = as.data.frame(cbind(y1,h1,x1,x2,x3,x4))
return(data)
}
data=dataGen4(100,0.3)
data=dataGen1(100,0.3)
data=dataGen2(100,0.3)
data=dataGen3(100,0.3)
library(dplyr)
library(here)
library(dplyr)
library(here)
### Master file ###
## Code for p-hacking and simulation
## This code has both a function that can look at interactionterms, multiple dependt variables and there average
## and different "outlier" criterias. These interactions are only with one other variable,
## but can be generalized such that it takes all interactions but the modelset will explode exponentially
#### Setting up the simulation ####
## Setting working directory
#setwd("C:/Users/jbda0002/Dropbox/Uppsala/Projects/P-Hacking paper/R")
setwd("C:/Users/jbda0002/Documents/Projects/P-hacking/trunk/R")
set.seed(1234)
## Loading library
library(ggplot2)
library(ggpubr)
library(data.table)
library(plyr)
library(reshape2)
library(Rlab)
library(tidyr)
library(doSNOW)
library(tcltk)
library(parallel)
library(doParallel)
library(foreach)
library(here)
##### Things that can be changed in the simulation
## Selecting the sample sizes that should be used
sample = c(200)
## Setting the number of repretetion
rep=20
## Setting the correlation between dependent and independent
per=c(0.2)
## Loading the P-Hacking function
source(here::here("phackingFunction_v2-0.R"))
## Making the list for the Normal Data
source("Data Generation Normal.R")
DataGenListNorm <- list(dataGen3)
## Making the list for the Bin Data
source("Data Generation Bin_v2-0.R")
DataGenListBin <- list(dataGen3)
## Making the list for the Bin Data
source("Data Generation BinNormal_v2-0.R")
DataGenListBinNorm <- list(dataGen3)
## Making the list for the Bin Data
source("Data Generation NormalBin.R")
DataGenListNormBin <- list(dataGen3)
#### Run the simulation ####
## General for all
## The different condetions
P2<-c("TRUE","FALSE")
P3<-c("TRUE","FALSE")
condSD<-c("TRUE","FALSE")
condMain<-c("TRUE","FALSE")
### Since there is a difference between the sets when Main is False and True two different simulations are made
#### Simulation for Main =T ####
## Collecting the different datatypes in one list
DataGen<-list(m1=DataGenListNorm,m2=DataGenListBin,m3=DataGenListNormBin,m4=DataGenListBinNorm)
## Choosing how many workers there should be used
cl <- makeSOCKcluster(20)
#clusterExport(cl,c("DataGen","sample","condIn","condSD"))
## Using the SNOW packed as this gives the ability to make a process bar
registerDoSNOW(cl)
## Making the process bar. The process bar will stand still towards the end, as it cannot take into account the time mapply will take
pb <- txtProgressBar(max=length(DataGenListBin)*length(DataGen)*length(condSD)*length(P2)*length(P3)*length(sample), style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
resultsMT<-
foreach(k=1:length(condSD),.combine=rbind) %:%
foreach(h=1:length(P2),.combine=rbind, .inorder=FALSE) %:%
foreach(c=1:length(per),.combine=rbind, .inorder=FALSE) %:%
foreach(l=1:length(P3),.combine=rbind, .inorder=FALSE) %:%
foreach(g=1:length(sample),.combine=rbind, .inorder=FALSE) %:%
foreach(i=1:length(DataGen),.combine=rbind, .inorder=F) %:%
foreach(j=1:length(DataGen[[i]]),.combine=rbind,.packages=c("plyr","statip","data.table","BinNor"), .inorder=FALSE) %dopar% {
f = function() {
x<-(replicate(rep, phackingFunction(DataGen[[i]][[j]](sample[[g]],per[[c]]),"y1","h1",Power_12 =P2[[h]],SD=condSD[[k]],Power_13 = P3[[l]],Main = T)))
Stats<-t(c(mean(x),(sd(x)/sqrt(length(x)))))
Stats
}
data.frame(f(),Power12=h,Power13=l,OutlierExclusion=k,IndependentVariables=j,Type=i,SampleSize=sample[[g]],Main=1,Correlation=per[[c]])
}
results<-as.data.frame(results)
names(results)[1]<-"Pr"
names(results)[2]<-"Sde"
## Close process bar
close(pb)
## Stop the workers
stopCluster(cl);print("Cluster stopped")
registerDoSEQ()
#### Simulation for Main = F ####
## Choosing how many workers there should be used
cl <- makeSOCKcluster(20)
#clusterExport(cl,c("DataGen","sample","condIn","condSD"))
## Using the SNOW packed as this gives the ability to make a process bar
registerDoSNOW(cl)
## Making the process bar. The process bar will stand still towards the end, as it cannot take into account the time mapply will take
pb <- txtProgressBar(max=length(DataGenListBin)*length(DataGen)*length(condSD)*length(P2)*length(P3)*length(sample), style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
resultsMF<-
foreach(k=1:length(condSD),.combine=rbind) %:%
foreach(h=1:length(P2),.combine=rbind, .inorder=FALSE) %:%
foreach(c=1:length(per),.combine=rbind, .inorder=FALSE) %:%
foreach(l=1:length(P3),.combine=rbind, .inorder=FALSE) %:%
foreach(g=1:length(sample),.combine=rbind, .inorder=FALSE) %:%
foreach(i=1:length(DataGen),.combine=rbind, .inorder=F) %:%
foreach(j=1:length(DataGen[[i]]),.combine=rbind,.packages=c("plyr","statip","data.table","BinNor"), .inorder=FALSE) %dopar% {
f = function() {
x<-(replicate(rep, phackingFunction(DataGen[[i]][[j]](sample[[g]],per[[c]]),"y1","h1",Power_2 =P2[[h]],SD=condSD[[k]],Power_3 = P3[[l]],Main = F)))
Stats<-t(c(mean(x),(sd(x)/sqrt(length(x)))))
Stats
}
data1=data.frame(f(),Power2=h,Power3=l,Power12=2,Power13=2,OutlierExclusion=k,IndependentVariables=j,Type=i,SampleSize=sample[[g]],Main=2,Correlation=per[[c]])
u = function() {
x<-(replicate(rep, phackingFunction(DataGen[[i]][[j]](sample[[g]],per[[c]]),"y1","h1",Power_12 =P2[[h]],SD=condSD[[k]],Power_13 = P3[[l]],Main = F)))
Stats<-t(c(mean(x),(sd(x)/sqrt(length(x)))))
Stats
}
data2=data.frame(u(),Power2=2,Power3=2,Power12=h,Power13=l,OutlierExclusion=k,IndependentVariables=j,Type=i,SampleSize=sample[[g]],Main=2,Correlation=per[[c]])
return(rbind(data1,data2))
}
results<-as.data.frame(results)
names(results)[1]<-"Pr"
names(results)[2]<-"Sde"
## Close process bar
close(pb)
## Stop the workers
stopCluster(cl);print("Cluster stopped")
registerDoSEQ()
finalresults<-dplyr::bind_rows(resultsMT, resultsMF)
finalresults[is.na(finalresults)] <- 2
names(finalresults)[1]<-"Pr"
names(finalresults)[2]<-"Sde"
finalresults$IndependentVariables=finalresults$IndependentVariables + 1
#### Simulation over sample size and correlation ####
## Here using the sets Ma + CCI and Ma + HCI
# Only using either Binary or Nomarl data
## Selecting the sample sizes that should be used
sample = c(50,100,150,200,250,300,350,400)
## Setting the correlation between dependent and independent
per=c(0.2,0.3,0.4)
## Collecting the different datatypes in one list
DataGen<-list(m1=DataGenListBin)
## Choosing how many workers there should be used
cl <- makeSOCKcluster(20)
## Using the SNOW packed as this gives the ability to make a process bar
registerDoSNOW(cl)
## Making the process bar. The process bar will stand still towards the end, as it cannot take into account the time mapply will take
pb <- txtProgressBar(max=length(DataGenListBin)*length(DataGen)*length(condSD)*length(P2)*length(P3)*length(sample)*length(condMain), style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
resultsSampleCor<-
foreach(h=1:length(P2),.combine=rbind, .inorder=FALSE) %:%
foreach(c=1:length(per),.combine=rbind, .inorder=FALSE) %:%
foreach(n=1:length(condMain),.combine=rbind, .inorder=FALSE) %:%
foreach(l=1:length(P3),.combine=rbind, .inorder=FALSE) %:%
foreach(g=1:length(sample),.combine=rbind, .inorder=FALSE) %:%
foreach(i=1:length(DataGen),.combine=rbind, .inorder=F) %:%
foreach(j=1:length(DataGen[[i]]),.combine=rbind,.packages=c("plyr","statip","data.table","BinNor"), .inorder=FALSE) %dopar% {
f = function() {
x<-(replicate(rep, phackingFunction(DataGen[[i]][[j]](sample[[g]],per[[c]]),"y1","h1",Power_12 =P2[[h]],Power_13 = P3[[l]],Main = condMain[[n]])))
Stats<-t(c(mean(x),(sd(x)/sqrt(length(x)))))
Stats
}
data.frame(f(),Power2=h,Power3=l,IndependentVariables=j,Type=i,SampleSize=sample[[g]],Main=n,Correlation=per[[c]])
}
resultsSampleCor<-as.data.frame(resultsSampleCor)
names(resultsSampleCor)[1]<-"Pr"
names(resultsSampleCor)[2]<-"Sde"
## Close process bar
close(pb)
## Stop the workers
stopCluster(cl);print("Cluster stopped")
registerDoSEQ()
### Figure 1
figureonedata<-finalresults[finalresults$SampleSize==200 & finalresults$Correlation==0.2 & finalresults$OutlierExclusion==2,]
figureonedata<-figureonedata[figureonedata$Power2==1 & figureonedata$Power3==2 & figureonedata$Power12==2 & figureonedata$Power13==2|
figureonedata$Power2==2 & figureonedata$Power3==1 & figureonedata$Power12==2 & figureonedata$Power13==2|
figureonedata$Power2==2 & figureonedata$Power3==2 & figureonedata$Power12==2 & figureonedata$Power13==2|
figureonedata$Power2==2 & figureonedata$Power3==2 & figureonedata$Power12==1 & figureonedata$Power13==2|
figureonedata$Power2==2 & figureonedata$Power3==2 & figureonedata$Power12==2 & figureonedata$Power13==1,]
figureonedata$Set<-ifelse(figureonedata$Power2==1 & figureonedata$Power3==2 & figureonedata$Power12==2 & figureonedata$Power13==2, "HCI",
ifelse(figureonedata$Power2==2 & figureonedata$Power3==2 & figureonedata$Power12==2 & figureonedata$Power13==2,"Ma",
ifelse(figureonedata$Power2==2 & figureonedata$Power3==1 & figureonedata$Power12==2 & figureonedata$Power13==2, "CCI",
ifelse(figureonedata$Power2==2 & figureonedata$Power3==2 & figureonedata$Power12==1 & figureonedata$Power13==2,"Ma + HCI",
ifelse(figureonedata$Power2==2 & figureonedata$Power3==2 & figureonedata$Power12==2 & figureonedata$Power13==1,"Ma + CCI",0)))))
figureonedata$Main[figureonedata$Main==1]<-"Main = TRUE"
figureonedata$Main[figureonedata$Main==2]<-"Main = FALSE"
figureonedata$Type[figureonedata$Type==1]<-"h1=Normal, Co=Normal"
figureonedata$Type[figureonedata$Type==2]<-"h1=Binary, Co=Binary"
figureonedata$Type[figureonedata$Type==3]<-"h1=Normal, Co=Binary"
figureonedata$Type[figureonedata$Type==4]<-"h1=Binary, Co=Normal"
figureonedata$Set <- factor(figureonedata$Se,levels = c("Ma", "HCI", "CCI", "Ma + HCI","Ma + CCI"))
Figure1 = ggplot(figureonedata)+
geom_bar(aes(x=Set,y=Pr), stat = "identity",position="dodge")+
facet_grid(Type~Main)+
theme_classic()+
geom_errorbar(aes(x=Set,ymin=Pr-Sde,ymax=Pr+Sde))
Figure1
#### Figure 2 ####
## Average affect over number of covariates
figuretwodata<-finalresults[finalresults$SampleSize==200 & finalresults$Correlation==0.2,]
figuretwodata<-figuretwodata[figuretwodata$Power2==1 & figuretwodata$Power3==2 & figuretwodata$Power12==2 & figuretwodata$Power13==2|
figuretwodata$Power2==2 & figuretwodata$Power3==1 & figuretwodata$Power12==2 & figuretwodata$Power13==2|
figuretwodata$Power2==2 & figuretwodata$Power3==2 & figuretwodata$Power12==2 & figuretwodata$Power13==2|
figuretwodata$Power2==2 & figuretwodata$Power3==2 & figuretwodata$Power12==1 & figuretwodata$Power13==2|
figuretwodata$Power2==2 & figuretwodata$Power3==2 & figuretwodata$Power12==2 & figuretwodata$Power13==1,]
figuretwodata$Set<-ifelse(figuretwodata$Power2==1 & figuretwodata$Power3==2 & figuretwodata$Power12==2 & figuretwodata$Power13==2, "HCI",
ifelse(figuretwodata$Power2==2 & figuretwodata$Power3==2 & figuretwodata$Power12==2 & figuretwodata$Power13==2,"Ma",
ifelse(figuretwodata$Power2==2 & figuretwodata$Power3==1 & figuretwodata$Power12==2 & figuretwodata$Power13==2, "CCI",
ifelse(figuretwodata$Power2==2 & figuretwodata$Power3==2 & figuretwodata$Power12==1 & figuretwodata$Power13==2,"Ma + HCI",
ifelse(figuretwodata$Power2==2 & figuretwodata$Power3==2 & figuretwodata$Power12==2 & figuretwodata$Power13==1,"Ma + CCI",0)))))
figuretwodata$Main[figuretwodata$Main==1]<-"Main = TRUE"
figuretwodata$Main[figuretwodata$Main==2]<-"Main = FALSE"
figuretwodata$Type[figuretwodata$Type==1]<-"h1=Normal, Co=Normal"
figuretwodata$Type[figuretwodata$Type==2]<-"h1=Binary, Co=Binary"
figuretwodata$Type[figuretwodata$Type==3]<-"h1=Normal, Co=Binary"
figuretwodata$Type[figuretwodata$Type==4]<-"h1=Binary, Co=Normal"
figuretwodata$OutlierExclusion[figuretwodata$OutlierExclusion==1]<-"TRUE"
figuretwodata$OutlierExclusion[figuretwodata$OutlierExclusion==2]<-"FALSE"
figuretwodata$Set <- factor(figuretwodata$Se,levels = c("Ma", "HCI", "CCI", "Ma + HCI","Ma + CCI"))
### Don't include this one, only state how this effect with an average
Figure2 = ggplot(figuretwodata)+
# geom_bar(aes(x=Set,y=Pr,fill=as.factor(IndependentVariables)), stat = "identity",position="dodge")+
geom_bar(aes(x=Set,y=Pr,fill=as.factor(OutlierExclusion)), stat = "identity",position="dodge")+
facet_grid(Type~Main)+
theme_classic()+
scale_fill_grey()
Figure2
### Figure 3 ###
## Here we will just make some examples
# In general there is no effect from sample size expect for Binary covarietes and not require main effect to be present
figurethreedata<-resultsSampleCor[ resultsSampleCor$Correlation==0.2,]
figurethreedata<-figurethreedata[figurethreedata$Power2==1 & figurethreedata$Power3==2 |
figurethreedata$Power2==2 & figurethreedata$Power3==1|
figurethreedata$Power2==2 & figurethreedata$Power3==2,]
figurethreedata$Set<-ifelse(figurethreedata$Power2==1 & figurethreedata$Power3==2 , "Ma + HCI",
ifelse(figurethreedata$Power2==2 & figurethreedata$Power3==2 ,"Ma",
ifelse(figurethreedata$Power2==2 & figurethreedata$Power3==1 , "Ma + CCI",0)))
figurethreedata$Main[figurethreedata$Main==1]<-"Main = TRUE"
figurethreedata$Main[figurethreedata$Main==2]<-"Main = FALSE"
figurethreedata$Type[figurethreedata$Type==1]<-"h1=Binary, Co=Binary"
figurethreedata$Set <- factor(figurethreedata$Se,levels = c("Ma", "Ma + HCI","Ma + CCI"))
Figure31 <-ggplot(aes(x=SampleSize, y=Pr), data=figurethreedata[figurethreedata$Type=="h1=Binary, Co=Binary",])+
geom_line(aes(colour=as.factor(IndependentVariables)),show.legend = FALSE) +
geom_point(aes(colour=as.factor(IndependentVariables)),show.legend = FALSE)+
scale_color_grey()+
facet_grid(Set~Main)+
ylab("")+
xlab("Sample size")+
theme_classic()
## Loading the P-Hacking function
source(here::here("phackingFunction_v2-0.R"))
#### Setting up the simulation ####
## Setting working directory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
set.seed(1234)
## Loading library
library(ggplot2)
library(ggpubr)
library(data.table)
library(plyr)
library(reshape2)
library(Rlab)
library(tidyr)
library(doSNOW)
library(tcltk)
library(parallel)
library(doParallel)
library(foreach)
library(here)
## Selecting the sample sizes that should be used
sample = c(200)
## Setting the number of repretetion
rep=20
## Setting the correlation between dependent and independent
per=c(0.2)
## Loading the P-Hacking function
source(here::here("phackingFunction_v2-0.R"))
#### Setting up the simulation ####
## Setting working directory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
set.seed(1234)
## Loading library
library(ggplot2)
library(jtools)
library(ggpubr)
library(data.table)
library(plyr)
library(reshape2)
library(Rlab)
library(tidyr)
library(doSNOW)
library(tcltk)
library(parallel)
library(doParallel)
library(foreach)
library(here)
## Selecting the sample sizes that should be used
sample = c(200,250,300)
## Setting the number of repretetion
rep=10
## Setting the correlation between dependent and independent
corr=c(0.2,0.3)
## Loading the P-Hacking function
source(here::here("phackingFunction_v2-0.R"))
### Here it is added how many covariates there should be in the simulation
## Making the list for the Normal Data
source("Data Generation Normal.R")
## Loading the P-Hacking function
source("phackingFunction_v2-0.R")
## Loading the P-Hacking function
source("phackingFunction_v2-0.R")
library(here)
